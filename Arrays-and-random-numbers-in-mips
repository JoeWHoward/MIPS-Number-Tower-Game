# random number generator
# it will generate 10 random numbers between 0 and 100

.data
# Create a string to separate the 100 numbers with a space
spacestr: 	.asciiz " " 

.text
##############################################################################
# seed the random number generator
##############################################################################

# get the time
li	$v0, 30		# get time in milliseconds (as a 64-bit value)
syscall

move	$t0, $a0	# save the lower 32-bits of time

# seed the random generator (just once)
li	$a0, 1		# random generator id (will be used later)
move 	$a1, $t0	# seed from time
li	$v0, 40		# seed random number generator syscall
syscall

##############################################################################
# seeding done
##############################################################################

# generate 10 random integers in the range 100 from the 
# seeded generator (whose id is 1)
li	$t2, 11		# max number of iterations + 1
li	$t3, 0		# current iteration number

LOOP:
li	$a0, 1		# as said, this id is the same as random generator id
li	$a1, 100	# upper bound of the range
li	$v0, 42		# random int range
syscall

# $a0 now holds the random number

# loop terminating condition
addi	$t3, $t3, 1	# increment the number of iterations
beq	$t3, $t2, EXIT	# branch to EXIT if iterations is 10

# $a0 still has the random number
# print it
li	$v0, 1		# print integer syscall
syscall

# print a space
la	$a0, spacestr	# load the address of the string (pseudo-op)	
li	$v0, 4		# print string syscall
syscall

# Do another iteration 
j	LOOP

##############################################################################
# Tell MARS to exit the program
##############################################################################
EXIT:
li	$v0, 10		# exit syscall
syscall






To access the data in the array requires that we know the address of the data and then use the load word (lw) or store word (sw) instructions.  Words (which is how integers are stored) in MIPS take up 32 bits or 4 bytes. Therefore, if we have a declaration such as:

 list:	.word 3, 0, 1, 2, 6, -2, 4, 7, 3, 7

the address that is loaded by the instruction la $t3, list is the address of the first '3' in the list.  The address of the '0' is 4 greater than that number, and the address of the '6' is 16 greater than that number.
The following snippet of code will place the value of list[6] into the $t4:

    la $t3, list         # put address of list into $t3
    li $t2, 6            # put the index into $t2
    add $t2, $t2, $t2    # double the index
    add $t2, $t2, $t2    # double the index again (now 4x)
    add $t1, $t2, $t3    # combine the two components of the address
    lw $t4, 0($t1)       # get the value from the array cell

If we wish to assign to the contents of $t4 to list[6] instead, the last line would simply be:

            sw $t4, 0($t1)      # store the value into the array cell




